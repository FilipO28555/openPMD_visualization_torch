#!/usr/bin/env python3
"""
Script to create MP4 videos from visualization images.
This script should be run after read_particle_momenta.py has generated the images.
"""
import os
import sys
import argparse
import subprocess
import re
from pathlib import Path
import cv2


def extract_iteration_number(filename):
    """
    Extract iteration number from filename like 'e_it_00123.png'
    Returns the iteration number as an integer for proper sorting.
    """
    match = re.search(r'_it_(\d+)', filename)
    if match:
        return int(match.group(1))
    return 0


def main():
    parser = argparse.ArgumentParser(
        description="Create MP4 videos from visualization images generated by read_particle_momenta.py"
    )
    parser.add_argument(
        "--series", required=True, 
        help="Path to simulation directory (same as used for read_particle_momenta.py)"
    )
    parser.add_argument(
        "--fps", type=int, default=30,
        help="Frames per second for the output video (default: 30)"
    )
    parser.add_argument(
        "--crf", type=int, default=18,
        help="Constant Rate Factor for video quality: 0 (lossless) to 51 (worst), default: 18 (visually lossless)"
    )
    parser.add_argument(
        "--debug", action="store_true",
        help="Enable verbose debug output"
    )
    
    args = parser.parse_args()
    base_series_path = args.series
    fps = args.fps
    crf = args.crf
    debug = args.debug
    
    # Get simulation folder name (last component of path)
    simulation_folder_name = os.path.basename(os.path.normpath(base_series_path))
    
    # Construct path to visualization folder
    visualization_path = os.path.join(base_series_path, "simOutput", "visualization")
    
    if not os.path.exists(visualization_path):
        print(f"Error: Visualization path does not exist: {visualization_path}")
        print("Please run read_particle_momenta.py first to generate the images.")
        return 1
    
    print("=" * 70)
    print("VIDEO CREATION PARAMETERS")
    print("=" * 70)
    print(f"Simulation folder:     {simulation_folder_name}")
    print(f"Visualization path:    {visualization_path}")
    print(f"FPS:                   {fps}")
    print(f"CRF (quality):         {crf}")
    print(f"Debug mode:            {'Enabled' if debug else 'Disabled'}")
    print("=" * 70)
    print()
    
    # Check if ffmpeg is available
    try:
        subprocess.run(['ffmpeg', '-version'], capture_output=True, check=True)
    except (FileNotFoundError, subprocess.CalledProcessError):
        print("Error: ffmpeg not found. Please install ffmpeg to create videos.")
        print("Install with: sudo apt-get install ffmpeg  (or equivalent for your system)")
        return 1
    
    print("Creating MP4 videos from images...")
    print("=" * 70)
    
    # Get all quantity folders (radial_momentum, tangential_momentum, kinetic_energy)
    quantity_dirs = [d for d in os.listdir(visualization_path) 
                     if os.path.isdir(os.path.join(visualization_path, d))]
    
    if not quantity_dirs:
        print(f"No quantity directories found in {visualization_path}")
        return 1
    
    video_count = 0
    error_count = 0
    
    for qty_name in sorted(quantity_dirs):
        qty_path = os.path.join(visualization_path, qty_name)
        
        # Map folder names to output names
        quantity_map = {
            'radial_momentum': 'momentum_radial',
            'tangential_momentum': 'momentum_tangential',
            'kinetic_energy': 'energy'
        }
        
        quantity_output_name = quantity_map.get(qty_name, qty_name)
        
        # Get all species folders within this quantity folder
        species_dirs = [d for d in os.listdir(qty_path) 
                       if os.path.isdir(os.path.join(qty_path, d))]
        
        for species_dir in sorted(species_dirs):
            species_path = os.path.join(qty_path, species_dir)
            
            # Find all PNG files in this directory and sort them numerically by iteration number
            png_files = [f for f in os.listdir(species_path) if f.endswith('.png')]
            png_files.sort(key=extract_iteration_number)
            
            if not png_files:
                if debug:
                    print(f"  No images found in {species_path}, skipping...")
                continue
            
            # Extract species name from directory name (e.g., "species_e" -> "e")
            species_name = species_dir.replace('species_', '')
            
            # Construct output video filename according to specification
            video_filename = f"{simulation_folder_name}_species_{species_name}_{quantity_output_name}.mp4"
            video_path = os.path.join(qty_path, video_filename)
            
            # Create a temporary file list for ffmpeg to ensure correct order
            file_list_path = os.path.join(species_path, 'ffmpeg_filelist.txt')
            with open(file_list_path, 'w') as f:
                for png_file in png_files:
                    # Use absolute path and escape special characters
                    abs_path = os.path.join(species_path, png_file)
                    # Write in ffmpeg concat format
                    f.write(f"file '{abs_path}'\n")
            
            # Get first image to verify it can be read
            first_img_path = os.path.join(species_path, png_files[0])
            first_img = cv2.imread(first_img_path)
            if first_img is None:
                print(f"  ✗ Could not read {first_img_path}, skipping...")
                error_count += 1
                # Clean up file list
                if os.path.exists(file_list_path):
                    os.remove(file_list_path)
                continue
            
            height, width = first_img.shape[:2]
            
            # Build ffmpeg command using concat demuxer for proper ordering
            cmd = [
                'ffmpeg', '-y',
                '-f', 'concat',
                '-safe', '0',
                '-r', str(fps),
                '-i', file_list_path,
                '-c:v', 'libx264',
                '-pix_fmt', 'yuv420p',  # yuv420p for better compatibility
                '-crf', str(crf),
                video_path
            ]
            
            print(f"  Creating: {video_filename}")
            print(f"    Source: {species_path} ({len(png_files)} frames, {width}x{height})")
            
            if debug:
                print(f"    Command: {' '.join(cmd)}")
            
            try:
                result = subprocess.run(cmd, capture_output=True, text=True)
                if result.returncode == 0:
                    # Get file size
                    file_size = os.path.getsize(video_path)
                    size_mb = file_size / (1024 * 1024)
                    print(f"    ✓ Success: {video_path} ({size_mb:.2f} MB)")
                    video_count += 1
                else:
                    print(f"    ✗ Error creating video")
                    error_count += 1
                    if debug:
                        print(f"    Error output: {result.stderr}")
            except Exception as e:
                print(f"    ✗ Error running ffmpeg: {e}")
                error_count += 1
            finally:
                # Clean up temporary file list
                if os.path.exists(file_list_path):
                    os.remove(file_list_path)
    
    print("=" * 70)
    print(f"\nVideo creation complete!")
    print(f"  Successfully created: {video_count} video(s)")
    if error_count > 0:
        print(f"  Errors encountered:   {error_count}")
    print()
    
    return 0 if error_count == 0 else 1


if __name__ == "__main__":
    sys.exit(main())
